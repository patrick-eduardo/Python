# -*- coding: utf-8 -*-
"""Caminhão_final (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nmphq9JcpiPn5xLW2AZBswLPSrQzIz5a
"""

import networkx as nx
import matplotlib.pyplot as plt
import heapq

# '''# Definindo o grafo como uma lista de adjacências
# matriz_adjacencia = [
# [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 0, 0, 0],
# [1, 0, 5, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# [0, 5, 0, 3, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0],
# [0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# [0, 0, 0, 7, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# [0, 0, 0, 0, 11, 0, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0],
# [0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],
# [3, 4, 0, 0, 0, 5, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0],
# [0, 0, 7, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 5],
# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 3, 2],
# [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 7, 0, 0, 0],
# [0, 0, 0, 0, 0, 0, 0, 4, 0, 23, 5, 0, 2, 0, 0, 0, 0],
# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 14, 1, 0, 0],
# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 2, 0, 0],
# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 4, 0],
# [0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0],
# [0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0, 0]
# ]

# # Função para converter a matriz em uma lista de adjacência
# def matriz_para_lista(matriz):

#     lista_adjacencia = {}
#     for i in range(len(matriz)):
#         lista_adjacencia[i] = []
#         for j in range(len(matriz[i])):
#             if matriz[i][j] != 0:
#                 lista_adjacencia[i].append((j, matriz[i][j]))
#     return lista_adjacencia

# grafo = matriz_para_lista(matriz_adjacencia)


# #Exibir lista
# # for vertice in grafo:
#     #  print(f"{vertice}: {grafo[vertice]}")

#Entradas
from google.colab import files
files.upload()

arquivo = open("ilhas.txt","r")

from collections import defaultdict

def grafo_NMS(arquivo):
  vetor = defaultdict(list)  # Initialize the dictionary with empty lists
  i=0
  for linha in arquivo:
    linha_div=linha.split()
    # if():
    vetor[i].append(linha_div)  # Append to the list at key 'i'
    i+=1

  return vetor

grafe = grafo_NMS(arquivo)
print(grafe)

# arestas[(n, m, s)] = grafe[0] #N, M, S
# print(arestas)

#grafo original
G = nx.Graph()
for u in grafo:
    for v, peso in grafo[u]:
        G.add_edge(u, v, weight=peso)

pos = nx.spring_layout(G)
plt.figure(figsize=(10, 6))

nx.draw(G, pos, with_labels=True, node_color='lightgreen', font_color= 'darkgreen', edge_color='lightblue')
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title('Arquipélago Nlogônia')
plt.show()

# Algoritmo de Prim - gerar MST (max)
def prim(grafo, vertice_inicial=1):
    mst = []
    visitados = set()
    arestas = [(-0, vertice_inicial, vertice_inicial)]  #atributos

    while arestas:
        peso, fonte, destino = heapq.heappop(arestas) # remover e retornar o menor item da heap
        if destino not in visitados:
            visitados.add(destino)
            if fonte != destino:
                mst.append((fonte, destino, -peso))
            for prox_destino, prox_peso in grafo[destino]:
                if prox_destino not in visitados:
                    heapq.heappush(arestas, (-prox_peso, destino, prox_destino)) #att heap

    return mst

grafo_mst = prim(grafo) #mst

#plot MST
MST = nx.Graph()
for u, v, peso in grafo_mst:
    MST.add_edge(u, v, weight=peso)

plt.figure(figsize=(10, 6))
pos= nx.planar_layout(MST)
nx.draw(MST, pos, with_labels=True, node_color='salmon', font_color= 'firebrick',edge_color='blue')
labels = nx.get_edge_attributes(MST, 'weight')
nx.draw_networkx_edge_labels(MST, pos, edge_labels=labels)
plt.title('Pontes de Interesse (MST)')
plt.show()

for _ range(M)

# Dijkstra - retornar menor peso do caminho
def diquistra(mst, inicio, fim):
    arestas = [(0, inicio, inicio)]
    distancias = {v: float('inf') for v in mst.nodes}
    distancias[inicio] = 0
    caminho = {v: None for v in mst.nodes}
    peso_minimo = float('inf')

    while arestas:
        dist_atual, vertice_atual, prev = heapq.heappop(arestas) # tirar menor valor heap

        if vertice_atual == fim:
            break

        for vizinho in mst.neighbors(vertice_atual):
            peso = mst[vertice_atual][vizinho]['weight']
            if vizinho == prev:  # Evitar voltar para o vértice anterior
                continue
            distancia = dist_atual + peso

            if distancia < distancias[vizinho]:
                distancias[vizinho] = distancia
                caminho[vizinho] = vertice_atual
                heapq.heappush(arestas, (distancia, vizinho, vertice_atual))

    # Encontrar o menor peso ao longo do caminho
    atual = fim
    while caminho[atual] is not None:
        vizinho = caminho[atual]
        peso_minimo = min(peso_minimo, mst[atual][vizinho]['weight'])
        atual = vizinho

    return peso_minimo if peso_minimo != float('inf') else None

#Entradas
while True:
    try:
        consultas = int(input("Entre com o número de sedes que deseja consultar: "))
        break
    except ValueError:
        print("Entrada inválida. Por favor, digite um número inteiro.")

for _ in range(consultas):
    while True:
        try:
            vertice_inicial = int(input("Início: "))
            vertice_final = int(input("Destino: "))
            if vertice_inicial in MST.nodes and vertice_final in MST.nodes:
                break
            else:
                print("Um ou ambos os vértices não existem no grafo. Tente novamente.")
        except ValueError:
               print("Entrada inválida. Por favor, digite números inteiros.")

#Resposta
    menor_peso = diquistra(MST, vertice_inicial, vertice_final)

    if menor_peso is not None:
        print(menor_peso)
    else:
        print(f"Não há caminho entre os vértices {vertice_inicial} e {vertice_final}.")